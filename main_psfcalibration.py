import os
import pickle
from tifffile import imwrite
import matplotlib.pyplot as plt
import numpy as np

from IMGProcess.ImageLoader import im_loader
from IMGProcess.ImageSegmentation.fim_ppicker import im_peakpicker2d
from IMGProcess.ImageSegmentation.fim_pseg import im_seg2d, ims_seg3d 
from PSFProcess.array_Utils import translate, mass_center
from PSFProcess.bspl_Utils import BSplineSmooth3D
from PSFProcess.psfplot_Utils import plot_psf_gauss2d, plot_psf_cspline2d, plot_psf_astigs, plot_psf_gauss3d, plot_psf_cspline3d
from PSFProcess.PSFanalysis_2D import PSFregister2D, PSFCalibration2D
from PSFProcess.PSFanalysis_3D import PSFGaussProfile3D, PSFregister3D, PSFCalibration3D_cspline, PSFCalibration3D_gauss



def _brief_disp(Calibration):
    """display the brief result of the calibration"""
    
    modality = Calibration['modality']
    nchannels = Calibration['nchannels']

    print("Calibration for modality {}:".format(Calibration['modality']))
    print("nchannels:\t{nchannels:d}".format(nchannels=nchannels))
    print("boxsz:\t{boxsz:d}".format(boxsz=Calibration['boxsz']))
    print("splszx:\t{splinesz:d}".format(splinesz=Calibration['splineszx']))
    if modality != '2Dfrm':
        print("splszz:\t{splinesz:d}".format(splinesz=Calibration['splineszz']))
    
    print("xmass at focus:", end='\t')
    print("\t".join(["{:+.3e}".format(Calibration['xmassc'][j]) for j in range(nchannels)]))
    print("ymass at focus:", end='\t')
    print("\t".join(["{:+.3e}".format(Calibration['ymassc'][j]) for j in range(nchannels)]))

    if modality != 'DH':
        print("sigx:", end='\t')
        print("\t".join(["{:.4e}".format(Calibration['PSFsigmax'][j] if modality=='2Dfrm' else Calibration['astigs'][j][0]) for j in range(nchannels)]))
        print("sigy:", end='\t')
        print("\t".join(["{:.4e}".format(Calibration['PSFsigmay'][j] if modality=='2Dfrm' else Calibration['astigs'][j][1]) for j in range(nchannels)]))    
    return



def _getBeads(ims, nbeads, boxsz, z0):
    """
    manually collect beads PSf from single-frame bead image
    INPUT:
        ims:                image dictionary generated by IMGProcess.ImageLoader.im_loader:
                            'roi':          [top, left, bottom, right] bounds for each roi
                            'cam_offset':   (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_offset from each channel within the roi
                            'cam_var':      (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_var from each channel within the roi, None if Camsetting['scmos_var'] == False
                            'cam_a2d':      (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_a2d from each channel within the roi
                            'cam_gain':     float, EMgain of the camera if avaiable
                            'imstack':      (nchannels, roiszy, roiszx) uint16 ndarray, image from each channel within the roi
        nbeads:             int, user-defined number of beads in each channel for calibration
        boxsz:              int, the size of the square box which will be used for experimental data fit
        z0:                 (nchannels,) int ndarray or int, the frame index of the focus frame, ignored if the input image is single frame
    RETURN:
        psfs:               (nchannels, nbeads, 2*boxsz+1, 2*boxsz+1) or (nchannels, nbeads, szz, 2*boxsz+1, 2*boxsz+1)
    """
    
    assert boxsz % 2 != 0, "boxsz not odd: boxsz={}".format(boxsz)
    splineszx = 2 * boxsz + 1 

    cam_offset  = ims['cam_offset']
    cam_a2d     = ims['cam_a2d']
    cam_gain    = ims['cam_gain']
    imbead      = ims['imstack']
    assert imbead.ndim in (3, 4), "ndim mismatch, imbead should be in a shape of (nchannels, szz, imszy, imszx) or (nchannels, imszy, imszx)"
    if imbead.ndim == 3:
        nchannels, imszy, imszx = imbead.shape
        psfs = np.zeros((nchannels, nbeads, splineszx, splineszx))
        im_focus = imbead.copy()
    else:
        nchannels, szz, imszy, imszx = imbead.shape
        psfs = np.zeros((nchannels, nbeads, szz, splineszx, splineszx))
        im_focus = imbead[:, z0, :, :] if np.isscalar(z0) else np.array([imbead[i, z0[i]] for i in range(nchannels)], dtype=imbead.dtype)
    
    for j in range(nchannels):
        print("picking beads in the {}-th channel...".format(j))
        indx, indy = im_peakpicker2d(im_focus[j], splineszx, nbeads)
        shiftx = np.zeros(nbeads)
        shifty = np.zeros(nbeads)
        for i in range(nbeads):
            dumim = im_seg2d(im_focus[j], splineszx, [indx[i]], [indy[i]], offset=cam_offset[j], a2d=cam_a2d[j]*cam_gain)[0]
            yc, xc = mass_center(dumim, np.array([1, 1]), norder=3)[0]
            
            shiftx[i] = xc - 0.5 * splineszx
            shifty[i] = yc - 0.5 * splineszx
            notedgex = indx[i] >= splineszx//2 and indx[i] < imszx - splineszx//2
            notedgey = indy[i] >= splineszx//2 and indy[i] < imszy - splineszx//2
            while (notedgex and np.abs(shiftx[i]) > 0.5) or (notedgey and np.abs(shifty[i]) > 0.5):
                dum_indx = indx[i] + np.int32(np.round(shiftx[i]))
                dum_indy = indy[i] + np.int32(np.round(shifty[i]))
                dumim = im_seg2d(im_focus[j], splineszx, [dum_indx], [dum_indy], offset=cam_offset[j], a2d=cam_a2d[j]*cam_gain)[0]
                yc, xc = mass_center(dumim,  np.array([4, 4]), norder=3)[0]
                dum_shiftx = xc - 0.5 * splineszx
                dum_shifty = yc - 0.5 * splineszx
                if np.abs(dum_shiftx) > 0.5 and np.abs(dum_shiftx) > np.abs(shiftx[i]):
                    break
                if np.abs(dum_shifty) > 0.5 and np.abs(dum_shifty) > np.abs(shifty[i]):
                    break
                indx[i] = dum_indx
                indy[i] = dum_indy
                shiftx[i] = dum_shiftx
                shifty[i] = dum_shifty
                notedgex = dum_indx >= splineszx//2 and dum_indx < imszx - splineszx//2
                notedgey = dum_indy >= splineszx//2 and dum_indy < imszy - splineszx//2

        if imbead.ndim == 4:
            raw_stack = ims_seg3d(imbead[j], splineszx, indx, indy, None, zrange=None, offset=cam_offset[j], a2d=cam_a2d[j]*cam_gain)
            for i in range(nbeads):
                psfs[j, i] = translate(raw_stack[i], (0.0, -shifty[i], -shiftx[i]))
        else:
            raw_stack = im_seg2d(imbead[j], splineszx, indx, indy, offset=cam_offset[j], a2d=cam_a2d[j]*cam_gain)
            for i in range(nbeads):
                psfs[j, i] = translate(raw_stack[i], (-shifty[i], -shiftx[i]))

    return psfs




########## Main Functions ##########
def PSFcali_2dfrm_unlinked(bead_fpath, ims, nbeads, boxsz, PSFsigmax, PSFsigmay):
    """
    main function to calibration beads in a bead image
    INPUT:
        bead_fpath:         the path to save the calibration results
        ims:                image dictionary generated by IMGProcess.ImageLoader.im_loader:
                            'roi':          [top, left, bottom, right] bounds for each roi
                            'cam_offset':   (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_offset from each channel within the roi
                            'cam_var':      (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_var from each channel within the roi, None if Camsetting['scmos_var'] == False
                            'cam_a2d':      (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_a2d from each channel within the roi
                            'cam_gain':     float, EMgain of the camera if avaiable
                            'imstack':      (nchannels, roiszy, roiszx) uint16 ndarray, image from each channel within the roi
        nbeads:             int, user-defined number of beads in each channel for calibration
        boxsz:              int, the size of the square box which will be used for experimental data fit
        PSFsigmax:          float, estimated sigmax of the PSF
        PSFsigmay:          float, estimated sigmay of the PSF
    """
    
    # parse the input
    assert boxsz % 2 != 0, "boxsz not odd: boxsz={}".format(boxsz)
    splineszx = 2 * boxsz + 1 
    imbead = ims['imstack']
    nchannels = len(imbead)
            
    # collect psfs from the nbeads
    psfs = _getBeads(ims, nbeads, boxsz, z0=0)
    
    # PSF alignment
    psf_norm = np.zeros((nchannels, splineszx, splineszx))
    psfs_shifted = np.zeros((nchannels, nbeads, splineszx, splineszx))
    shifts = np.zeros((nchannels, nbeads, 2))
    indgood = np.zeros((nchannels, nbeads), dtype=bool)
    for j in range(nchannels):
        psf_norm[j], psfs_shifted[j], shifts[j], indgood[j] = PSFregister2D(psfs[j], boxsz, filterf0=False)
        print("shifts of each bead [shifty, shiftx] in channel {}...".format(j))
        print(shifts[j])
        bkg = psf_norm[j].min()
        Photon = np.sum(psf_norm[j] - bkg)
        psf_norm[j] = (psf_norm[j] - bkg) / Photon
        psfs_shifted[j] = (psfs_shifted[j] - bkg) / Photon
    psfs_shifted[psfs_shifted < 0.0] = 0.0
    
    PSF_registration = dict()
    PSF_registration['nchannels']       = nchannels
    PSF_registration['psf_norm']        = psf_norm
    PSF_registration['psfs_shifted']    = psfs_shifted
    PSF_registration['shifts']          = shifts
    PSF_registration['indgood']         = indgood
    with open(os.path.join(bead_fpath, 'PSF_registration.pkl'), 'wb') as fid:
        pickle.dump(PSF_registration, fid, pickle.HIGHEST_PROTOCOL)
    psf_norm_tif = 65535 * np.concatenate(psf_norm, axis=-1)
    imwrite(os.path.join(bead_fpath, 'PSF_aligned.tif'), psf_norm_tif.astype(np.uint16))

    # PSF calibration
    Calibration = dict()
    Calibration['modality']     = '2Dfrm'
    Calibration['nchannels']    = nchannels
    Calibration['boxsz']        = boxsz
    Calibration['zFocus']       = 0
    cspline_validation, gauss_validation = PSFCalibration2D(psf_norm, Calibration, PSFsigmax, PSFsigmay)
    
    with open(os.path.join(bead_fpath, 'PSFCalibration_2dfrm_unlinked.pkl'), 'wb') as fid:
        pickle.dump(Calibration, fid, pickle.HIGHEST_PROTOCOL)
    fname = os.path.join(bead_fpath, 'gaussValidation_2dfrm_unlinked.dat')
    
    headline = 'xc\tyc\tphoton\tbg'
    np.savetxt(fname, gauss_validation, fmt='%f', delimiter='\t', header=headline, comments='')
    fname = os.path.join(bead_fpath, 'csplineValidation_2dfrm_unlinked.dat')
    headline = 'xc\tyc\tphoton\tbg'
    np.savetxt(fname, cspline_validation, fmt='%f', delimiter='\t', header=headline, comments='')
    
    fig_cspline = plot_psf_cspline2d(psf_norm, Calibration)
    fig_cspline.savefig(os.path.join(bead_fpath, 'csplineCalibration_unlinked.png'), dpi=300)
    plt.close(fig_cspline)
    fig_gauss = plot_psf_gauss2d(psf_norm, Calibration)
    fig_gauss.savefig(os.path.join(bead_fpath, 'gaussCalibration_unlinked.png'), dpi=300)
    plt.close(fig_gauss)
    
    _brief_disp(Calibration)

    return



def PSFcali_3dstck_unlinked(modality, bead_fpath, ims, nbeads, boxsz, PSFsigmax, PSFsigmay, zstepsz_nm, z_f0, cal_zrange, reg_zrange=25, smoothZ=1.0, nbreaks=20):
    """
    main function to calibration Astigmatic beads in a stack (w/ cylindrical lens)
    INPUT:
        modality:           str, {'2D', 'AS', 'DH', 'BP'} for 2D, Astigmatism, DoubleHelix, BiPlane calibration
        bead_fpath:         the path to save the calibration results
        ims:                image dictionary generated by IMGProcess.ImageLoader.im_loader:
                            'roi':      [top, left, bottom, right] bounds for each roi
                            'cam_offset':   (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_offset from each channel within the roi
                            'cam_var':      (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_var from each channel within the roi, None if Camsetting['scmos_var'] == False
                            'cam_a2d':      (nchannels, roiszy, roiszx) or (nchannels,) float ndarray, cam_a2d from each channel within the roi
                            'cam_gain':     float, EMgain of the camera if avaiable
                            'imstack':      (nchannels, roiszy, roiszx) uint16 ndarray, image from each channel within the roi
        nbeads:             int, user-defined number of beads in each channel for calibration
        boxsz:              int, the size of the square box which will be used for experimental data fit
        PSFsigmax:          float, estimated sigmax of the PSF, ignored if modality == 'DH'
        PSFsigmay:          float, estimated sigmay of the PSF, ignored if modality == 'DH'
        zstepsz_nm:         float, the stepsz in nm during z-scanning calibration
        z_f0:               (nchannels,) int ndarray or int, the z position of the focus 
        cal_zrange:         int, user-defined axial range for gauss fit of the PSF
        reg_zrange:         int, user-defined lateral range for cross-correlation-based alignment
        smoothZ:            float, the smoothing factor along the axial axis, default at 1 which brings visualbe but not too much smoothing along the axial profile
        nbreaks:            int, number of grid for spline fit
    """
    
    # parse the inputs
    assert modality in ('2D', 'AS', 'DH', 'BP'), "unsupported modality"
    assert boxsz % 2 != 0, "boxsz must be odd"
    assert cal_zrange % 2 != 0, "the cal_zrange_int must be odd"
    assert reg_zrange % 2 != 0, "the reg_zrange_int must be odd"
    splineszx = 2 * boxsz + 1 
    imbead = ims['imstack']
    nchannels, imszz, imszy, imszx = imbead.shape
    if np.isscalar(z_f0):
        assert z_f0 - reg_zrange // 2 >= 0 and z_f0 + reg_zrange // 2 < imszz, "reg_zrange={} out of imszz={} with z_focus={}".format(reg_zrange, imszz, z_f0)
        z_f0 = np.zeros(nchannels, dtype=np.int32) + z_f0
    else:
        assert np.min(z_f0) - reg_zrange // 2 >= 0 and np.max(z_f0) + reg_zrange // 2 < imszz, "reg_zrange={} out of imszz={} with z_focus={}".format(reg_zrange, imszz, z_f0)
    lmbdaZ = smoothZ / zstepsz_nm * 100.0

    # collect psfs from the nbeads
    psfs = _getBeads(ims, nbeads, boxsz, z0=z_f0)
    if modality != 'DH':
        individual_bead_gauss = [[dict() for _ in range(nbeads)] for _ in range(nchannels)]
        for j in range(nchannels):
            for i in range(nbeads):
                individual_bead_gauss[j][i] = PSFGaussProfile3D(psfs[j, i], None, PSFsigmax, PSFsigmay, cal_zrange, 'MLE', lmbdaZ=lmbdaZ)
            
        with open(os.path.join(bead_fpath, 'Individual_bead_gauss.pkl'), 'wb') as fid:
            pickle.dump(individual_bead_gauss, fid, pickle.HIGHEST_PROTOCOL)
        fig_astigs = plot_psf_astigs(individual_bead_gauss)
        fig_astigs.savefig(os.path.join(bead_fpath, 'Individual_bead_gauss.png'), dpi=300)
        plt.close(fig_astigs)

    # PSF registration
    psf_norm = np.zeros((nchannels, imszz, splineszx, splineszx))
    psfs_shifted = np.zeros((nchannels, nbeads, imszz, splineszx, splineszx))
    shifts = np.zeros((nchannels, nbeads, 3))
    indgood = np.zeros((nchannels, nbeads), dtype=bool)
    for j in range(nchannels):
        psf_norm[j], psfs_shifted[j], shifts[j], indgood[j] = PSFregister3D(psfs[j], z_f0[j], reg_zrange, reg_xyrange=boxsz, filterf0=False)
        psf_norm[j] = BSplineSmooth3D(psf_norm[j], (3, 0, 0), (lmbdaZ, 0.0, 0.0))
        for i in range(nbeads):
            psfs_shifted[j, i] = BSplineSmooth3D(psfs_shifted[j, i], (3, 0, 0), (lmbdaZ, 0.0, 0.0))
        print("shifts of each bead [shiftz, shifty, shiftx] in channel_{}".format(j))
        print(shifts[j])
    
    for j in range(nchannels):
        psf_focus = np.mean(psf_norm[j, z_f0[j]-1:z_f0[j]+2], axis=0)
        bkg = psf_focus.min()
        Photon = np.sum(psf_focus - bkg)
        psf_norm[j] = (psf_norm[j] - bkg) / Photon
        psfs_shifted[j] = (psfs_shifted[j] - bkg) / Photon
    psf_norm[psf_norm < 0.0] = 0.0
    psfs_shifted[psfs_shifted < 0.0] = 0.0
    
    PSF_registration = dict()
    PSF_registration['nchannels']       = nchannels
    PSF_registration['zFocus']          = z_f0
    PSF_registration['cal_range']       = cal_zrange
    PSF_registration['psf_norm']        = psf_norm
    PSF_registration['psfs_shifted']    = psfs_shifted
    PSF_registration['shifts']          = shifts
    PSF_registration['indgood']         = indgood
    with open(os.path.join(bead_fpath, 'PSF_registration.pkl'), 'wb') as fid:
        pickle.dump(PSF_registration, fid, pickle.HIGHEST_PROTOCOL)
    psf_norm_tif = 65535 * np.concatenate(psf_norm, axis=-1)
    imwrite(os.path.join(bead_fpath, 'PSF_aligned.tif'), psf_norm_tif.astype(np.uint16))
    
    # PSF calibration
    zmin = max(np.int32(np.mean(z_f0))-cal_zrange//2, 0)
    zmax = min(np.int32(np.mean(z_f0))+cal_zrange//2, imszz-1)
    psf_kernel = psf_norm[:, zmin : zmax+1]
    Calibration = dict()
    Calibration['modality']     = modality
    Calibration['nchannels']    = nchannels
    Calibration['boxsz']        = boxsz
    Calibration['zFocus']       = z_f0
    Calibration['zstepsz_nm']   = zstepsz_nm
    cspline_validation = PSFCalibration3D_cspline(psf_kernel, Calibration)
    if modality != 'DH':
        astigmatic2d_result, gauss_validation = PSFCalibration3D_gauss(psf_kernel, Calibration, PSFsigmax, PSFsigmay, nbreaks)
    
    # collect the information
    with open(os.path.join(bead_fpath, 'PSFCalibration_unlinked.pkl'), 'wb') as fid:
        pickle.dump(Calibration, fid, pickle.HIGHEST_PROTOCOL)
    fig_cspline = plot_psf_cspline3d(Calibration)
    fig_cspline.savefig(os.path.join(bead_fpath, 'csplineCalibration_unlinked.png'), dpi=300)
    plt.close(fig_cspline)
    headline = 'xc\tyc\tzc\tphoton\tbg\tLS'
    for j in range(nchannels):
        fname = os.path.join(bead_fpath, 'csplineValidation_unlinked_chnl{}.dat'.format(j))
        np.savetxt(fname, cspline_validation[j], fmt='%f', delimiter='\t', header=headline, comments='')
    
    if modality != 'DH':
        fig_gauss = plot_psf_gauss3d(Calibration, astigmatic2d_result, gauss_validation)
        fig_gauss.savefig(os.path.join(bead_fpath, 'gaussCalibration_unlinked.png'), dpi=300)
        plt.close(fig_gauss)
        for j in range(nchannels):
            fname = os.path.join(bead_fpath, 'gaussSliceAs2D_unlinked_chnl{}.dat'.format(j))
            headline = 'xc\tyc\tphoton\tbg\tsigmax\tsigmay\tLS' 
            np.savetxt(fname, astigmatic2d_result[j], fmt='%f', delimiter='\t', header=headline, comments='')
            fname = os.path.join(bead_fpath, 'gaussValidation_unlinked_chnl{}.dat'.format(j))
            headline = 'xc\tyc\tzc\tphoton\tbg\tLS'
            np.savetxt(fname, gauss_validation[j], fmt='%f', delimiter='\t', header=headline, comments='')
        
    _brief_disp(Calibration)
    
    return






########## Driver Functions ##########
if __name__ == '__main__':
    
    #################### INPUTS #####################
    modality = '2D'
    bead_fullfname = 'D:/Data/SMLM_challange/beads/z-stack-Beads-'+ modality +'-Exp-as-stack/sequence-as-stack-Beads-' + modality + '-Exp.tif'

    # Camera setup
    Camsetting = dict()    
    Camsetting['cam_pth']   = None
    Camsetting['view_type'] = 'dualview' if modality == 'BP' else 'fullview'
    Camsetting['chipszh']   = 150       # unit = pixel
    Camsetting['chipszw']   = 300 if modality == 'BP' else 150
    Camsetting['offset']    = 100.0
    Camsetting['var']       = 74.4
    Camsetting['A2D']       = 1.0 / 45.0
    Camsetting['EMGain']    = 300.0 
    Camsetting['scmos_var'] = False
    Camsetting['cam_pxszx'] = 100.0     # unit = nm
    Camsetting['cam_pxszy'] = 100.0     # unit = nm
    
    # Axial Information
    zstepsz_nm = 10.0       # unit = nm
    zfocus = 75             # unit = slice
    cal_zrange_nm = 1500.0  # unit = nm
    
    ### Beads Information
    boxsz = 13
    nbeads = 6                            
    
    ### Working parameters
    PSFsigmax_nm = 143.0     # unit = nm, initial guess of the size of the PSFsigma
    PSFsigmay_nm = 143.0     # unit = nm, initial guess of the size of the PSFsigma

    #################### PARSE THE INPUTS #####################
    bead_fpath = os.path.dirname(bead_fullfname)
    with open(os.path.join(bead_fpath, 'Camera_settings.pkl'), 'wb') as fid:
        pickle.dump(Camsetting, fid, pickle.HIGHEST_PROTOCOL)

    # working parameters
    PSFsigmax = PSFsigmax_nm / Camsetting['cam_pxszx']
    PSFsigmay = PSFsigmay_nm / Camsetting['cam_pxszy']
    cal_zrange = 2 * np.int32(cal_zrange_nm/2.0/zstepsz_nm+0.5) + 1
    nbreaks = np.int32(cal_zrange_nm/50+0.5)

    # rearange the frames according to view_type, modify the camera specs in-place
    ims, = im_loader(Camsetting, bead_fullfname)

    #################### RUN CALIBRATION #####################
    PSFcali_3dstck_unlinked(modality, bead_fpath, ims, nbeads, boxsz, PSFsigmax, PSFsigmay, zstepsz_nm, zfocus, cal_zrange, reg_zrange=25, smoothZ=1.0, nbreaks=nbreaks)
    